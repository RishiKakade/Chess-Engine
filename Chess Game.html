<!DOCTYPE html>

<html> 

<head> 
	
	<title> Chess Game </title>
	
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"> </script>

<style type="text/css">

	#fen {

		position: relative;
		left: 60px;

	}

	#fenIn {

		width: 480px;
		left: 60px;

	}

	#Board {

		position: relative;
		top: 20px;
		left: 60px;
		width: 480px;
		height: 480px;
		border-style: solid;
		border-width: 2px;
	}

	#EngineOutput {

		position: absolute;
		left: 600px;
		top: 250px;

	}

	.Square {

		position: absolute;
		width: 60px;
		height: 60px;

	}

	.Dark {

		background-color: #5fbcd3;

	}

	.Light {

		background-color: #afdde9;

	}

	.SquareSelected {

		background-color: #216778;

	}

	.clickElement {

		cursor: pointer

	}

	.Rank1 { 

		top: 420px;

	}

	.Rank2 { 

		top: 360px;

	}

	.Rank3 { 

		top: 300px;

	}

	.Rank4 { 

		top: 240px;

	}

	.Rank5 { 

		top: 180px;

	}

	.Rank6 { 

		top: 120px;

	}

	.Rank7 { 

		top: 60px;

	}

	.Rank8 { 

		top: 0px;

	}

	.File1 {

		left: 0px;

	}

	.File2 {

		left: 60px;

	}

	.File3 {

		left: 120px;

	}

	.File4 {

		left: 180px;

	}

	.File5 {

		left: 240px;

	}

	.File6 {

		left: 300px;

	}

	.File7 {

		left: 360px;

	}

	.File8 {

		left: 420px;

	}

	.Piece {

		position: absolute;

	}

</style>

</head>

<body>

	<h1> Chess Game </h1>

<div id="fen">

	FEN: 

	<br>

	<input type="text" id="fenIn">

	<button id="setFEN"> Set Position </button>

</div>
<div id="Board">

</div>

<div id="EngineOutput"> Thinking Time: <br/>

	<select id="ThinkTimeChoice">

		<option value="1"> 1s </option>
		<option value="2"> 2s </option>
		<option value="4"> 4s </option>
		<option value="6"> 6s </option>
		<option value="8"> 8s </option>
		<option value="10"> 10s </option>

	</select> <br/> <br/> <br/>

	<span id="BestMove"> Best Move: </span> <br/>
	<span id="Depth"> Depth: </span> <br/>
	<span id="Score"> Score: </span> <br/>
	<span id="Nodes"> Nodes: </span> <br/>
	<span id="Ordering"> Ordering: </span> <br/>
	<span id="Time"> Time: </span> <br/> <br/>

	<button id="Search"> Move Now </button> <br/>
	<button id="NewGame"> New Game </button> <br/>
	<button id="FlipBoard"> Flip Board </button> <br/> <br/>
	<button id="TakeBack"> Take Back </button> <br/> <br/> <br/>

	<span id="GameStatus"> </span>

</div>

<script type="text/javascript">
	
	var Pieces = { Empty: 0, whitePawn: 1, whiteKnight: 2, whiteBishop: 3, whiteRook: 4, whiteQueen: 5, whiteKing: 6,
		       blackPawn: 7, blackKnight: 8, blackBishop: 9, blackRook: 10, blackQueen: 11, blackKing: 12 };

	var Board = 120;
	var Files = { fileA: 0, fileB: 1, fileC: 2, fileD: 3, fileE: 4, fileF: 5, fileG: 6, fileH: 7, fileNone: 8 };
	var Ranks = { rank1: 0, rank2: 1, rank3: 2, rank4: 3, rank5: 4, rank6: 5, rank7: 6, rank8: 7, rankNone: 8 };
	var MirrorFiles = [ Files.fileH, Files.fileG, Files.fileF, Files.fileE, Files.fileD, Files.fileC, Files.fileB, Files.fileA ];
	var MirrorRanks = [ Ranks.rank8, Ranks.rank7, Ranks.rank6, Ranks.rank5, Ranks.rank4, Ranks.rank3, Ranks.rank2, Ranks.rank1 ];
	var Colours = { white: 0, black: 1, both: 2 };
	var Castle = { whiteKingSideCastle: 1, whiteQueenSideCastle: 2, blackKingSideCastle: 4, blackQueenSideCastle: 8 };
	var Squares = { A1: 21, B1: 22, C1: 23, D1: 24, E1: 25, F1: 26, G1: 27, H1: 28, A8: 91, B8: 92, C8: 93, 
		        D8: 94, E8: 95, F8: 96, G8: 97, H8: 98, noSquare: 99, offBoard: 100 };

	var Bool = { false: 0, true: 1 };
	var maxGameMoves = 2048;
	var maxPositionMoves = 256;
	var maxDepth = 64;
	var infinite = 30000;
	var mate = 29000;
	var PvEntries = 10000;
	var filesBoard = new Array(Board);
	var ranksBoard = new Array(Board);
	var startFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
	var PieceChar = ".PNBRQKpnbrqk";
	var SideChar = "wb-";
	var RankChar = "12345678";
	var FileChar = "abcdefgh";

	function FilePlusRankOnSquare (f, r){

		return ( (21 + (f) ) + (10 * (r) ) );

	}

	var PieceBig = [ Bool.false, Bool.false, Bool.true, Bool.true, Bool.true, Bool.true, Bool.true, Bool.false, Bool.true, Bool.true, Bool.true, Bool.true, Bool.true ];
	var PieceMajor = [ Bool.false, Bool.false, Bool.false, Bool.false, Bool.true, Bool.true, Bool.true, Bool.false, Bool.false, Bool.false, Bool.true, Bool.true, Bool.true ];
	var PieceMinor = [ Bool.false, Bool.false, Bool.true, Bool.true, Bool.false, Bool.false, Bool.false, Bool.false, Bool.true, Bool.true, Bool.false, Bool.false, Bool.false ];
	var PieceValue= [ 0, 100, 325, 325, 550, 1000, 50000, 100, 325, 325, 550, 1000, 50000  ];
	var PieceColour = [ Colours.both, Colours.white, Colours.white, Colours.white, Colours.white, Colours.white, Colours.white,
	                    Colours.black, Colours.black, Colours.black, Colours.black, Colours.black, Colours.black ];
	
	var PiecePawn = [ Bool.false, Bool.true, Bool.false, Bool.false, Bool.false, Bool.false, Bool.false, Bool.true, Bool.false, Bool.false, Bool.false, Bool.false, Bool.false ];	
	var PieceKnight = [ Bool.false, Bool.false, Bool.true, Bool.false, Bool.false, Bool.false, Bool.false, Bool.false, Bool.true, Bool.false, Bool.false, Bool.false, Bool.false ];
	var PieceKing = [ Bool.false, Bool.false, Bool.false, Bool.false, Bool.false, Bool.false, Bool.true, Bool.false, Bool.false, Bool.false, Bool.false, Bool.false, Bool.true ];
	var PieceRookQueen = [ Bool.false, Bool.false, Bool.false, Bool.false, Bool.true, Bool.true, Bool.false, Bool.false, Bool.false, Bool.false, Bool.true, Bool.true, Bool.false ];
	var PieceBishopQueen = [ Bool.false, Bool.false, Bool.false, Bool.true, Bool.false, Bool.true, Bool.false, Bool.false, Bool.false, Bool.true, Bool.false, Bool.true, Bool.false ];
	var PieceSlides = [ Bool.false, Bool.false, Bool.false, Bool.true, Bool.true, Bool.true, Bool.false, Bool.false, Bool.false, Bool.true, Bool.true, Bool.true, Bool.false ];
	var KnightDirections = [ -8, -19, -21, -12, 8, 19, 21, 12 ];
	var RookDirections = [ -1, -10, 1, 10 ];
	var BishopDirections = [ -9, -11, 11, 9 ];
	var KingDirections = [ -1, -10, 1, 10, -9, -11, 11, 9 ];
	var NumberOfDirections = [ 0, 0, 8, 4, 4, 8, 8, 0, 8, 4, 4, 8, 8 ];
	var PieceDirections = [ 0, 0, KnightDirections, BishopDirections, RookDirections, KingDirections, KingDirections, 0, KnightDirections, BishopDirections, RookDirections, KingDirections, KingDirections ];
	var LoopNonSlidePieces = [ Pieces.whiteKnight, Pieces.whiteKing, 0, Pieces.blackKnight, Pieces.blackKing, 0 ];
	var LoopNonSlidePiecesIndex = [0, 3];
	var LoopSlidePieces = [ Pieces.whiteBishop, Pieces.whiteRook, Pieces.whiteQueen, 0, Pieces.blackBishop, Pieces.blackRook, Pieces.blackQueen, 0 ];
	var LoopSlidePiecesIndex = [0, 4];
	var PieceKeys = new Array(14 * 120);
	var SideKey;
	var CastleKeys = new Array(16);
	var Square120ToSquare64 = new Array(Board);
	var Square64ToSquare120 = new Array(64);
	var perftLeafNodes;

	function Random31(){

		return (Math.floor((Math.random()*255)+1) << 23) | (Math.floor((Math.random()*255)+1) << 16) | (Math.floor((Math.random()*255)+1) << 8) | Math.floor((Math.random()*255)+1);

	}

	var Mirror64 = [
	56, 57,	58, 59,	60, 61,	62, 63,
	48, 49,	50, 51,	52, 53,	54, 55,
	40, 41,	42, 43,	44, 45,	46, 47,
	32, 33,	34, 35,	36, 37,	38, 39,
	24, 25,	26, 27,	28, 29,	30, 31,
	16, 17,	18, 19,	20, 21,	22, 23,
	8, 9, 10, 11, 12, 13, 14, 15,
	0, 1, 2, 3, 4, 5, 6, 7 ];

	function Square64(square120){

		return Square120ToSquare64[(square120)];

	}

	function Square120(square64){

		return Square64ToSquare120[(square64)];

	}

	function PieceIndex(piece, pieceNumber){

		return (piece * 10 + pieceNumber);

	}

	function MIRROR64(square){

		return Mirror64[square];

	}

	function PrintSquare(square){

		return (FileChar[filesBoard[square]] + RankChar[ranksBoard[square]]);

	}

	function PrintMove(move){

		var MoveString;
		var fileFrom = filesBoard[FromSquare(move)];
		var rankFrom = ranksBoard[FromSquare(move)];
		var fileTo = filesBoard[ToSquare(move)];
		var rankTo = ranksBoard[ToSquare(move)];
		var promoted = Promoted(move);

		MoveString = FileChar[fileFrom] + RankChar[rankFrom] + FileChar[fileTo] + RankChar[rankTo];

		if (promoted != Pieces.Empty){

			var pieceChar = 'q';

			if (PieceKnight[promoted] == Bool.true){

				pieceChar = 'n';

			} else if (PieceRookQueen[promoted] == Bool.true && PieceBishopQueen[promoted] == Bool.false) {

				pieceChar = 'r';

			} else if (PieceRookQueen[promoted] == Bool.false && PieceBishopQueen[promoted] == Bool.true) {

				pieceChar = 'b';

			}

			MoveString += pieceChar;

		}

		return MoveString;

	}

	function PrintMoveList(){

		var index; 
		var move;

		console.log('MoveList:');

		for(index = GameBoard.moveListStart[GameBoard.ply]; index < GameBoard.moveListStart[GameBoard.ply+1]; ++index){

			move = GameBoard.moveList[index];
			console.log(PrintMove(move));
		}
	}

	function ParseMove(from, to) {

		GenerateMoves();

		var Move = NoMove;
		var PromotedPiece = Pieces.Empty;
		var found = Bool.false;

		for(index = GameBoard.moveListStart[GameBoard.ply]; index < GameBoard.moveListStart[GameBoard.ply + 1]; ++index){

			Move = GameBoard.moveList[index];

			if(FromSquare(Move) == from && ToSquare(Move) == to) {

				PromotedPiece = Promoted(Move);

				if(PromotedPiece != Pieces.Empty) {
					if((PromotedPiece == Pieces.whiteQueen && GameBoard.side == Colours.white) || (PromotedPiece == Pieces.blackQueen && GameBoard.side == Colours.black)){

						found = Bool.true;
						break;

					}

					continue;

				}

				found = Bool.true;
				break;

			}
		}

		if(found != Bool.false){
			if(MakeMove(Move) == Bool.false){

				return NoMove;

			}

			TakeMove();
			return Move;

		}

		return NoMove;

	}

	var GameBoard = {};
	
	GameBoard.pieces = new Array(Board);
	GameBoard.side = Colours.white;
	GameBoard.fiftyMove = 0;
	GameBoard.hisPly = 0;
	GameBoard.history = [];
	GameBoard.ply = 0;
	GameBoard.enPassant = 0;
	GameBoard.castlePermission = 0;
	GameBoard.material = new Array(2);
	GameBoard.pieceNumber = new Array(13);
	GameBoard.pieceList = new Array(14 * 10);
	GameBoard.positionKey = 0;
	GameBoard.moveList = new Array(maxDepth * maxPositionMoves);
	GameBoard.moveScores = new Array(maxDepth * maxPositionMoves);
	GameBoard.moveListStart = new Array(maxDepth);
	GameBoard.PvTable = [];
	GameBoard.PvArray = new Array(maxDepth);
	GameBoard.searchHistory = new Array(14 * Board);
	GameBoard.searchKillers = new Array(3 * maxDepth);

	function CheckBoard(){

		var targetPieceNumber = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
		var targetMaterial = [ 0, 0 ];
		var square64, targetPiece, targetPieceNumber2, square120, colour, pieceCount;

		for(targetPiece = Pieces.whitePawn; targetPiece <= Pieces.blackKing; ++targetPiece){
			for(targetPieceNumber2 = 0; targetPieceNumber2 < GameBoard.pieceNumber[targetPiece]; ++targetPieceNumber2){

				square120 = GameBoard.pieceList[PieceIndex(targetPiece, targetPieceNumber2)];

				if(GameBoard.pieces[square120] != targetPiece){

					console.log('Error Piece Lists');
					return Bool.false;

				}
			}
		}

		for(square64 = 0; square64 < 64; ++square64){

			square120 = Square120(square64);
			targetPiece = GameBoard.pieces[square120];
			targetPieceNumber[targetPiece]++;
			targetMaterial[PieceColour[targetPiece]] += PieceValue[targetPiece];

		}

		for(targetPiece = Pieces.whitePawn; targetPiece <= Pieces.blackKing; ++targetPiece){

			if(targetPieceNumber[targetPiece] != GameBoard.pieceNumber[targetPiece]){

				console.log('Error targetPieceNumber');
				return Bool.false;

			}
		}

		if(targetMaterial[Colours.white] != GameBoard.material[Colours.white] || targetMaterial [Colours.black] != GameBoard.material[Colours.black]){

			console.log('Error targetMaterial');
			return Bool.false;

		}

		if(GameBoard.side != Colours.white && GameBoard.side != Colours.black){

			console.log('Error GameBoard.side');
			return Bool.false;

		} 

		if(GeneratePositionKey() != GameBoard.positionKey){

			console.log('Error GameBoard.positionKey');
			return Bool.false;

		}

		return Bool.true

	}

	function PrintBoard(){

		var square, file, rank, piece;

		console.log("\nGame Board:\n");

		for(rank = Ranks.rank8; rank >= Ranks.rank1; rank--){

			var line = (RankChar[rank] + " ");

			for(file = Files.fileA; file <= Files.fileH; file++){

				square = FilePlusRankOnSquare(file, rank);
				piece = GameBoard.pieces[square];
				line += (" " + PieceChar[piece] + " ");

			}

			console.log(line);

		}

		console.log("");

		var line = "   ";

		for(file = Files.fileA; file <= Files.fileH; file++){

			line += (' ' + FileChar[file] + ' ');

		}

		console.log(line);
		console.log("side:" + SideChar[GameBoard.side] );
		console.log("enPas:" + GameBoard.enPassant);
		line = "";

		if(GameBoard.castlePermission & Castle.whiteKingSideCastle) line += 'K';
		if(GameBoard.castlePermission & Castle.whiteQueenSideCastle) line += 'Q';
		if(GameBoard.castlePermission & Castle.blackKingSideCastle) line += 'k';
		if(GameBoard.castlePermission & Castle.blackQueenSideCastle) line += 'q';

		console.log("castle:" + line);
		console.log("key:" + GameBoard.positionKey.toString(16));

	}

	function GeneratePositionKey(){

		var square = 0;
		var finalKey = 0;
		var piece = Pieces.Empty;

		for(square = 0; square < Board; ++square){

			piece = GameBoard.pieces[square];

			if(piece != Pieces.Empty && piece != Squares.offBoard){

				finalKey ^= PieceKeys[(piece * 120) + square];

			}
		}

		if(GameBoard.side == Colours.white){

			finalKey ^= SideKey;

		}

		if(GameBoard.enPassant != Squares.noSquare){

			finalKey ^= PieceKeys[GameBoard.enPassant];

		}

		finalKey ^= CastleKeys[GameBoard.castlePermission];

		return finalKey;

	}

	function PrintPieceLists(){

		var piece, pieceNumber;

		for(piece = Pieces.whitePawn; piece <= Pieces.blackKing; ++piece){
			for(pieceNumber = 0; pieceNumber < GameBoard.pieceNumber[piece]; ++pieceNumber){

				console.log('piece ' + PieceChar[piece] + ' on ' + PrintSquare(GameBoard.pieceList[PieceIndex(piece, pieceNumber)]));

			}
		}
	}

	function UpdateListsMaterial(){

		var piece, square, index, colour;

		for(index = 0; index < 14 * 10; ++index){

			GameBoard.pieceList[index] = Pieces.Empty;

		}

		for(index = 0; index < 2; ++index){

			GameBoard.material[index] = 0;

		}

		for(index = 0; index < 13; ++index){

			GameBoard.pieceNumber[index] = 0;

		}

		for(index = 0; index < 64; ++index){

			square = Square120(index);
			piece = GameBoard.pieces[square];

			if(piece != Pieces.Empty){

				colour = PieceColour[piece];
				GameBoard.material[colour] += PieceValue[piece];
				GameBoard.pieceList[PieceIndex(piece, GameBoard.pieceNumber[piece])] = square;
				GameBoard.pieceNumber[piece]++;

			}
		}
	}

	function ResetBoard(){

		var index = 0;

		for(index = 0; index < Board; ++index){

			GameBoard.pieces[index] = Squares.offBoard;

		}

		for(index = 0; index < 64; ++index){

			GameBoard.pieces[Square120(index)] = Pieces.Empty;

		}

		GameBoard.side = Colours.both;
		GameBoard.enPassant = Squares.noSquare;
		GameBoard.fiftyMove = 0;
		GameBoard.ply = 0;
		GameBoard.halfMoves = 0;
		GameBoard.castlePermission = 0;
		GameBoard.positionKey = 0;
		GameBoard.moveListStart[GameBoard.ply] = 0;

	}

	function ParseFEN(fen){

		ResetBoard();
	
		var rank = Ranks.rank8;
		var file = Files.fileA;
		var piece = 0;
		var count = 0;
		var i = 0;
		var square120 = 0;
		var fenCount = 0;

		while ((rank >= Ranks.rank1) && fenCount < fen.length){

			count = 1;

			switch (fen[fenCount]){

				case 'p': piece = Pieces.blackPawn; break;
				case 'r': piece = Pieces.blackRook; break;
				case 'n': piece = Pieces.blackKnight; break;
				case 'b': piece = Pieces.blackBishop; break;
				case 'k': piece = Pieces.blackKing; break;
				case 'q': piece = Pieces.blackQueen; break;
				case 'P': piece = Pieces.whitePawn; break;
				case 'R': piece = Pieces.whiteRook; break;
				case 'N': piece = Pieces.whiteKnight; break;
				case 'B': piece = Pieces.whiteBishop; break;
				case 'K': piece = Pieces.whiteKing; break;
				case 'Q': piece = Pieces.whiteQueen; break;
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':

					piece = Pieces.Empty;
					count = fen[fenCount].charCodeAt() - '0'.charCodeAt();
					break;

				case '/':
				case ' ':
					
					rank--;
					file = Files.fileA;
					fenCount++;
					continue;

				default:

					console.log("FEN error");
					return;

			}

			for (i = 0; i < count; i++){

				square120 = FilePlusRankOnSquare(file, rank);
				GameBoard.pieces[square120] = piece;
				file++;

			}

			fenCount++;

		}

		GameBoard.side = (fen[fenCount] == 'w' ) ? Colours.white : Colours.black;
		fenCount += 2;

		for (i = 0; i < 4; i++){

			if (fen[fenCount] == ' '){
			
				break;

			}

			switch(fen[fenCount]){

				case 'K': GameBoard.castlePermission |= Castle.whiteKingSideCastle; break;
				case 'Q': GameBoard.castlePermission |= Castle.whiteQueenSideCastle; break;
				case 'k': GameBoard.castlePermission |= Castle.blackKingSideCastle; break;
				case 'q': GameBoard.castlePermission |= Castle.blackQueenSideCastle; break;

				default: break;

			}

			fenCount++;

		}

		fenCount++;

		if (fen[fenCount] != '-'){

			file = fen[fenCount].charCodeAt() - 'a'.charCodeAt();
			rank = fen[fenCount + 1].charCodeAt() - '1'.charCodeAt();
			console.log("fen[fenCount]:" + fen[fenCount] + " File:" + file + " Rank:" + rank);
			GameBoard.enPassant = FilePlusRankOnSquare(file, rank);

		}

		GameBoard.positionKey = GeneratePositionKey();
		UpdateListsMaterial();

	}

	function PrintSquareAttacked(){

		var square, file, rank, piece;

		console.log("\nAttacked:\n");

		for(rank = Ranks.rank8; rank >= Ranks.rank1; rank--){

			var line = ((rank+1) + " ");
			for(file = Files.fileA; file <= Files.fileH; file ++){

				square = FilePlusRankOnSquare(file, rank);
				if(SquareAttacked(square, GameBoard.side) == Bool.true) piece = "X";
				else piece = "-";
				line += (" " + piece + " ");

			}

			console.log(line);

		}

		console.log("");

	}

	function SquareAttacked(square, side){

		var piece;
		var t_square;
		var index;

		if(side == Colours.white){
			if(GameBoard.pieces[square - 11] == Pieces.whitePawn || GameBoard.pieces[square - 9] == Pieces.whitePawn){

				return Bool.true;

			}
		} else {

			if(GameBoard.pieces[square + 11] == Pieces.blackPawn || GameBoard.pieces[square + 9] == Pieces.blackPawn){

				return Bool.true;

			}
		}

		for(index = 0; index < 8; index++){

			piece = GameBoard.pieces[square + KnightDirections[index]];
			if(piece != Squares.offBoard && PieceColour[piece] == side && PieceKnight[piece] == Bool.true){

				return Bool.true;

			}
		}

		for(index = 0; index < 4; ++index){

			directions = RookDirections[index];
			t_square = square + directions;
			piece = GameBoard.pieces[t_square];
			while(piece != Squares.offBoard){
		
				if(piece != Pieces.Empty){
					if(PieceRookQueen[piece] == Bool.true && PieceColour[piece] == side){

						return Bool.true;

					}

					break;

				}

				t_square += directions;
				piece = GameBoard.pieces[t_square];

			}
		}

		for(index = 0; index < 4; ++index){

			directions = BishopDirections[index];
			t_square = square + directions;
			piece = GameBoard.pieces[t_square];
			while(piece != Squares.offBoard){
		
				if(piece != Pieces.Empty){
					if(PieceBishopQueen[piece] == Bool.true && PieceColour[piece] == side){

						return Bool.true;

					}

					break;

				}

				t_square += directions;
				piece = GameBoard.pieces[t_square];

			}
		}

		for(index = 0; index < 8; index++){

			piece = GameBoard.pieces[square + KingDirections[index]];
			if(piece != Squares.offBoard && PieceColour[piece] == side && PieceKing[piece] == Bool.true){

				return Bool.true;

			}
		}

		return Bool.false;

	}

	var Kings = [Pieces.whiteKing, Pieces.blackKing];
	var CastlePermission = [
	15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
	15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
	15, 13, 15, 15, 15, 12, 15, 15, 14, 15,
	15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
	15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
	15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
	15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
	15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
	15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
	15, 7, 15, 15, 15, 3, 15, 15, 11, 15,
	15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
	15, 15, 15, 15, 15, 15, 15, 15, 15, 15
	];

	function FromSquare(m) { return (m & 0x7F);}
	function ToSquare(m) { return ((m >> 7) & 0x7F);}
	function Captured(m) { return ((m >> 14) & 0xF);}
	function Promoted(m) { return ((m >> 20) & 0xF);}

	var MoveFlagEnPassant = 0x40000;
	var MoveFlagPawnStart = 0x80000;
	var MoveFlagCastling = 0x1000000;
	var MoveFlagCapture = 0x7C000;
	var MoveFlagPromotion = 0xF00000;
	var NoMove = 0;

	function SquareOffBoard(square){

		if(filesBoard[square] == Squares.offBoard) return Bool.true;
		return Bool.false;

	}

	function HashPiece(piece, square){

		GameBoard.positionKey ^= PieceKeys[(piece * 120) + square];

	}

	function HashCastling() { GameBoard.positionKey ^= CastleKeys[GameBoard.castlePermission]; }
	function HashSide() { GameBoard.positionKey ^= SideKey; }
	function HashEnPassant() { GameBoard.positionKey ^= PieceKeys[GameBoard.enPassant]; }

	var GameController = {};

	GameController.EngineSide = Colours.both;
	GameController.Playerside = Colours.both;
	GameController.BoardFlipped = Bool.false;
	GameController.GameOver = Bool.false;

	var UserMove = {};

	UserMove.from = Squares.noSquare;
	UserMove.to = Squares.noSquare;

	var MvvLvaValue = [ 0, 100, 200, 300, 400, 500, 600, 100, 200, 300, 400, 500, 600 ];
	var MvvLvaScores = new Array(14 * 14);

	function InitMvvLva(){

		var Attacker;
		var Victim;

		for(Attacker = Pieces.whitePawn; Attacker <= Pieces.blackKing; ++Attacker){
			for(Victim = Pieces.whitePawn; Victim <= Pieces.blackKing; ++Victim){

				MvvLvaScores[Victim * 14 + Attacker] = MvvLvaValue[Victim] + 6 - (MvvLvaValue[Attacker]/100);

			}
		}
	}

	function MoveExists(move){

		GenerateMoves();

		var index;
		var moveFound = NoMove;

		for(index = GameBoard.moveListStart[GameBoard.ply]; index < GameBoard.moveListStart[GameBoard.ply + 1]; ++index){

			moveFound = GameBoard.moveList[index];

			if(MakeMove(moveFound) == Bool.false){

				continue;

			}

			TakeMove();

			if(move == moveFound){

				return Bool.true;

			}
		}

		return Bool.false;

	}

	function Move(from, to, captured, promoted, flag){

		return (from | (to << 7) | (captured << 14) | (promoted << 20) | flag);

	}

	function AddCaptureMove(move){

		GameBoard.moveList[GameBoard.moveListStart[GameBoard.ply+1]] = move;
		GameBoard.moveScores[GameBoard.moveListStart[GameBoard.ply+1]++] = MvvLvaScores[Captured(move) * 14 + GameBoard.pieces[FromSquare(move)]] + 1000000;

	}

	function AddQuietMove(move){

		GameBoard.moveList[GameBoard.moveListStart[GameBoard.ply+1]] = move;
		GameBoard.moveScores[GameBoard.moveListStart[GameBoard.ply+1]] = 0;

		if(move == GameBoard.searchKillers[GameBoard.ply]){

			GameBoard.moveScores[GameBoard.moveListStart[GameBoard.ply+1]] = 900000;

		} else if (move == GameBoard.searchKillers[GameBoard.ply + maxDepth]){

			GameBoard.moveScores[GameBoard.moveListStart[GameBoard.ply+1]] = 800000;

		} else {

			GameBoard.moveScores[GameBoard.moveListStart[GameBoard.ply+1]] = GameBoard.searchHistory[GameBoard.pieces[FromSquare(move)] * Board + ToSquare(move)]

		}

		GameBoard.moveListStart[GameBoard.ply+1]++

	}

	function AddEnPassantMove(move){

		GameBoard.moveList[GameBoard.moveListStart[GameBoard.ply+1]] = move;
		GameBoard.moveScores[GameBoard.moveListStart[GameBoard.ply+1]++] = 105 + 1000000;

	}

	function AddWhitePawnCaptureMove(from, to, capture){

		if(ranksBoard[from]==Ranks.rank7){

			AddCaptureMove(Move(from, to, capture, Pieces.whiteQueen, 0));
			AddCaptureMove(Move(from, to, capture, Pieces.whiteRook, 0));
			AddCaptureMove(Move(from, to, capture, Pieces.whiteBishop, 0));
			AddCaptureMove(Move(from, to, capture, Pieces.whiteKnight, 0));

		} else {

			AddCaptureMove(Move(from, to, capture, Pieces.Empty, 0));

		}
	}

	function AddBlackPawnCaptureMove(from, to, capture){

		if(ranksBoard[from]==Ranks.rank2){

			AddCaptureMove(Move(from, to, capture, Pieces.blackQueen, 0));
			AddCaptureMove(Move(from, to, capture, Pieces.blackRook, 0));
			AddCaptureMove(Move(from, to, capture, Pieces.blackBishop, 0));
			AddCaptureMove(Move(from, to, capture, Pieces.blackKnight, 0));

		} else {

			AddCaptureMove(Move(from, to, capture, Pieces.Empty, 0));

		}
	}

	function AddWhitePawnQuietMove(from, to){

		if(ranksBoard[from]==Ranks.rank7){

			AddQuietMove(Move(from, to, Pieces.Empty, Pieces.whiteQueen, 0));
			AddQuietMove(Move(from, to, Pieces.Empty, Pieces.whiteRook, 0));
			AddQuietMove(Move(from, to, Pieces.Empty, Pieces.whiteBishop, 0));
			AddQuietMove(Move(from, to, Pieces.Empty, Pieces.whiteKnight, 0));

		} else {

			AddQuietMove(Move(from, to, Pieces.Empty, Pieces.Empty, 0));

		}
	}

	function AddBlackPawnQuietMove(from, to){

		if(ranksBoard[from]==Ranks.rank2){

			AddQuietMove(Move(from, to, Pieces.Empty, Pieces.blackQueen, 0));
			AddQuietMove(Move(from, to, Pieces.Empty, Pieces.blackRook, 0));
			AddQuietMove(Move(from, to, Pieces.Empty, Pieces.blackBishop, 0));
			AddQuietMove(Move(from, to, Pieces.Empty, Pieces.blackKnight, 0));

		} else {

			AddQuietMove(Move(from, to, Pieces.Empty, Pieces.Empty, 0));

		}
	}

	function GenerateMoves(){

		GameBoard.moveListStart[GameBoard.ply+1] = GameBoard.moveListStart[GameBoard.ply];

		var pieceType;
		var pieceNumber;
		var square;
		var pieceIndex;
		var piece;
		var targetSquare;
		var directions;

		if (GameBoard.side == Colours.white){

			pieceType = Pieces.whitePawn;

			for (pieceNumber = 0; pieceNumber < GameBoard.pieceNumber[pieceType]; ++pieceNumber){

				square = GameBoard.pieceList[PieceIndex(pieceType, pieceNumber)];

				if (GameBoard.pieces[square + 10] == Pieces.Empty){

					AddWhitePawnQuietMove(square, square + 10);

					if (ranksBoard[square] == Ranks.rank2 && GameBoard.pieces[square + 20] == Pieces.Empty){

						AddQuietMove(Move(square, square+20, Pieces.Empty, Pieces.Empty, MoveFlagPawnStart));

					}
				}

				if (SquareOffBoard(square + 9) == Bool.false && PieceColour[GameBoard.pieces[square + 9]] == Colours.black){

					AddWhitePawnCaptureMove(square, square + 9, GameBoard.pieces[square + 9]);

				}

				if (SquareOffBoard(square + 11) == Bool.false && PieceColour[GameBoard.pieces[square + 11]] == Colours.black){

					AddWhitePawnCaptureMove(square, square + 11, GameBoard.pieces[square + 11]);

				}

				if (GameBoard.enPassant != Squares.noSquare){
					if (square + 9 == GameBoard.enPassant){

						AddEnPassantMove(Move(square, square+9, Pieces.Empty, Pieces.Empty, MoveFlagEnPassant));

					}

					if (square + 11 == GameBoard.enPassant){

						AddEnPassantMove(Move(square, square+11, Pieces.Empty, Pieces.Empty, MoveFlagEnPassant));

					}
				}
			}

			if (GameBoard.castlePermission & Castle.whiteKingSideCastle){
				if (GameBoard.pieces[Squares.F1] == Pieces.Empty && GameBoard.pieces[Squares.G1] == Pieces.Empty){
					if (SquareAttacked(Squares.F1, Colours.black) == Bool.false && SquareAttacked(Squares.E1, Colours.black) == Bool.false){

						AddQuietMove(Move(Squares.E1, Squares.G1, Pieces.Empty, Pieces.Empty, MoveFlagCastling));

					}
				}
			}

			if (GameBoard.castlePermission & Castle.whiteQueenSideCastle){
				if (GameBoard.pieces[Squares.D1] == Pieces.Empty && GameBoard.pieces[Squares.C1] == Pieces.Empty && GameBoard.pieces[Squares.B1] == Pieces.Empty){
					if (SquareAttacked(Squares.D1, Colours.black) == Bool.false && SquareAttacked(Squares.E1, Colours.black) == Bool.false){

						AddQuietMove(Move(Squares.E1, Squares.C1, Pieces.Empty, Pieces.Empty, MoveFlagCastling));

					}
				}
			}
		} else {

			pieceType = Pieces.blackPawn;

			for (pieceNumber = 0; pieceNumber < GameBoard.pieceNumber[pieceType]; ++pieceNumber){

				square = GameBoard.pieceList[PieceIndex(pieceType, pieceNumber)];

				if (GameBoard.pieces[square - 10] == Pieces.Empty){

					AddBlackPawnQuietMove(square, square - 10);

					if (ranksBoard[square] == Ranks.rank7 && GameBoard.pieces[square - 20] == Pieces.Empty){

						AddQuietMove(Move(square, square - 20, Pieces.Empty, Pieces.Empty, MoveFlagPawnStart));

					}
				}

				if (SquareOffBoard(square - 9) == Bool.false && PieceColour[GameBoard.pieces[square - 9]] == Colours.white){

					AddBlackPawnCaptureMove(square, square - 9, GameBoard.pieces[square - 9]);

				}

				if (SquareOffBoard(square - 11) == Bool.false && PieceColour[GameBoard.pieces[square - 11]] == Colours.white){

					AddBlackPawnCaptureMove(square, square - 11, GameBoard.pieces[square - 11]);

				}

				if (GameBoard.enPassant != Squares.noSquare){
					if (square - 9 == GameBoard.enPassant){

						AddEnPassantMove(Move(square, square-9, Pieces.Empty, Pieces.Empty, MoveFlagEnPassant));

					}

					if (square - 11 == GameBoard.enPassant){

						AddEnPassantMove(Move(square, square-11, Pieces.Empty, Pieces.Empty, MoveFlagEnPassant));

					}
				}
			}

			if (GameBoard.castlePermission & Castle.blackKingSideCastle){
				if (GameBoard.pieces[Squares.F8] == Pieces.Empty && GameBoard.pieces[Squares.G8] == Pieces.Empty){
					if (SquareAttacked(Squares.F8, Colours.white) == Bool.false && SquareAttacked(Squares.E8, Colours.white) == Bool.false){

						AddQuietMove(Move(Squares.E8, Squares.G8, Pieces.Empty, Pieces.Empty, MoveFlagCastling));

					}
				}
			}

			if (GameBoard.castlePermission & Castle.blackQueenSideCastle){
				if (GameBoard.pieces[Squares.D8] == Pieces.Empty && GameBoard.pieces[Squares.C8] == Pieces.Empty && GameBoard.pieces[Squares.B8] == Pieces.Empty){
					if (SquareAttacked(Squares.D8, Colours.white) == Bool.false && SquareAttacked(Squares.E8, Colours.white) == Bool.false){

						AddQuietMove(Move(Squares.E8, Squares.C8, Pieces.Empty, Pieces.Empty, MoveFlagCastling));

					}
				}
			}
		}

		pieceIndex = LoopNonSlidePiecesIndex[GameBoard.side];
		piece = LoopNonSlidePieces[pieceIndex++];

		while (piece != 0) {

			for(pieceNumber = 0; pieceNumber < GameBoard.pieceNumber[piece]; ++pieceNumber){

				square = GameBoard.pieceList[PieceIndex(piece, pieceNumber)];

				for(index = 0; index < NumberOfDirections[piece]; index++){

					directions = PieceDirections[piece][index];
					targetSquare = square + directions;

					if (SquareOffBoard(targetSquare) == Bool.true){

						continue;

					}

					if (GameBoard.pieces[targetSquare] != Pieces.Empty){
						if(PieceColour[GameBoard.pieces[targetSquare]] != GameBoard.side){

							AddCaptureMove(Move(square, targetSquare, GameBoard.pieces[targetSquare], Pieces.Empty, 0));

						}
					} else {

						AddQuietMove(Move(square, targetSquare, Pieces.Empty, Pieces.Empty, 0));

					}
				}
			}

			piece = LoopNonSlidePieces[pieceIndex++];
			
		}

		pieceIndex = LoopSlidePiecesIndex[GameBoard.side];
		piece = LoopSlidePieces[pieceIndex++];

		while (piece != 0) {

			for(pieceNumber = 0; pieceNumber < GameBoard.pieceNumber[piece]; ++pieceNumber){

				square = GameBoard.pieceList[PieceIndex(piece, pieceNumber)];

				for(index = 0; index < NumberOfDirections[piece]; index++){

					directions = PieceDirections[piece][index];
					targetSquare = square + directions;

					while (SquareOffBoard(targetSquare) == Bool.false){

						if (GameBoard.pieces[targetSquare] != Pieces.Empty){
							if(PieceColour[GameBoard.pieces[targetSquare]] != GameBoard.side){

								AddCaptureMove(Move(square, targetSquare, GameBoard.pieces[targetSquare], Pieces.Empty, 0));

							}
								
							break;
							
						}

						AddQuietMove(Move(square, targetSquare, Pieces.Empty, Pieces.Empty, 0));
						targetSquare += directions;

					}
				}
			}

			piece = LoopSlidePieces[pieceIndex++];
		}
	}

	function GenerateCaptures(){

		GameBoard.moveListStart[GameBoard.ply+1] = GameBoard.moveListStart[GameBoard.ply];

		var pieceType;
		var pieceNumber;
		var square;
		var pieceIndex;
		var piece;
		var targetSquare;
		var directions;

		if (GameBoard.side == Colours.white){

			pieceType = Pieces.whitePawn;

			for (pieceNumber = 0; pieceNumber < GameBoard.pieceNumber[pieceType]; ++pieceNumber){

				square = GameBoard.pieceList[PieceIndex(pieceType, pieceNumber)];

				if (SquareOffBoard(square + 9) == Bool.false && PieceColour[GameBoard.pieces[square + 9]] == Colours.black){

					AddWhitePawnCaptureMove(square, square + 9, GameBoard.pieces[square + 9]);

				}

				if (SquareOffBoard(square + 11) == Bool.false && PieceColour[GameBoard.pieces[square + 11]] == Colours.black){

					AddWhitePawnCaptureMove(square, square + 11, GameBoard.pieces[square + 11]);

				}

				if (GameBoard.enPassant != Squares.noSquare){
					if (square + 9 == GameBoard.enPassant){

						AddEnPassantMove(Move(square, square+9, Pieces.Empty, Pieces.Empty, MoveFlagEnPassant));

					}

					if (square + 11 == GameBoard.enPassant){

						AddEnPassantMove(Move(square, square+11, Pieces.Empty, Pieces.Empty, MoveFlagEnPassant));

					}
				}
			}
		} else {

			pieceType = Pieces.blackPawn;

			for (pieceNumber = 0; pieceNumber < GameBoard.pieceNumber[pieceType]; ++pieceNumber){

				square = GameBoard.pieceList[PieceIndex(pieceType, pieceNumber)];

				if (SquareOffBoard(square - 9) == Bool.false && PieceColour[GameBoard.pieces[square - 9]] == Colours.white){

					AddBlackPawnCaptureMove(square, square - 9, GameBoard.pieces[square - 9]);

				}

				if (SquareOffBoard(square - 11) == Bool.false && PieceColour[GameBoard.pieces[square - 11]] == Colours.white){

					AddBlackPawnCaptureMove(square, square - 11, GameBoard.pieces[square - 11]);

				}

				if (GameBoard.enPassant != Squares.noSquare){
					if (square - 9 == GameBoard.enPassant){

						AddEnPassantMove(Move(square, square-9, Pieces.Empty, Pieces.Empty, MoveFlagEnPassant));

					}

					if (square - 11 == GameBoard.enPassant){

						AddEnPassantMove(Move(square, square-11, Pieces.Empty, Pieces.Empty, MoveFlagEnPassant));

					}
				}
			}
		}

		pieceIndex = LoopNonSlidePiecesIndex[GameBoard.side];
		piece = LoopNonSlidePieces[pieceIndex++];

		while (piece != 0) {

			for(pieceNumber = 0; pieceNumber < GameBoard.pieceNumber[piece]; ++pieceNumber){

				square = GameBoard.pieceList[PieceIndex(piece, pieceNumber)];

				for(index = 0; index < NumberOfDirections[piece]; index++){

					directions = PieceDirections[piece][index];
					targetSquare = square + directions;

					if (SquareOffBoard(targetSquare) == Bool.true){

						continue;

					}

					if (GameBoard.pieces[targetSquare] != Pieces.Empty){
						if(PieceColour[GameBoard.pieces[targetSquare]] != GameBoard.side){

							AddCaptureMove(Move(square, targetSquare, GameBoard.pieces[targetSquare], Pieces.Empty, 0));

						}

						continue;

					}
				}
			}

			piece = LoopNonSlidePieces[pieceIndex++];
			
		}

		pieceIndex = LoopSlidePiecesIndex[GameBoard.side];
		piece = LoopSlidePieces[pieceIndex++];

		while (piece != 0) {

			for(pieceNumber = 0; pieceNumber < GameBoard.pieceNumber[piece]; ++pieceNumber){

				square = GameBoard.pieceList[PieceIndex(piece, pieceNumber)];

				for(index = 0; index < NumberOfDirections[piece]; index++){

					directions = PieceDirections[piece][index];
					targetSquare = square + directions;

					while (SquareOffBoard(targetSquare) == Bool.false){

						if (GameBoard.pieces[targetSquare] != Pieces.Empty){
							if(PieceColour[GameBoard.pieces[targetSquare]] != GameBoard.side){

								AddCaptureMove(Move(square, targetSquare, GameBoard.pieces[targetSquare], Pieces.Empty, 0));

							}
								
							break;
							
						}

						targetSquare += directions;

					}
				}
			}

			piece = LoopSlidePieces[pieceIndex++];
		}
	}

	function ClearPiece(square){

		var piece = GameBoard.pieces[square];
		var colour = PieceColour[piece];
		var index;
		var targetPieceNumber = -1;

		HashPiece(piece, square);

		GameBoard.pieces[square] = Pieces.Empty; 
		GameBoard.material[colour] -= PieceValue[piece];

		for(index = 0; index < GameBoard.pieceNumber[piece]; ++index){

			if(GameBoard.pieceList[PieceIndex(piece, index)] == square){

				targetPieceNumber = index;
				break;

			}
		}

		GameBoard.pieceNumber[piece]--;
		GameBoard.pieceList[PieceIndex(piece, targetPieceNumber)] = GameBoard.pieceList[PieceIndex(piece, GameBoard.pieceNumber[piece])];

	}

	function AddPiece(square, piece){

		var colour = PieceColour[piece];

		HashPiece(piece, square);

		GameBoard.pieces[square] = piece;
		GameBoard.material[colour] += PieceValue[piece];
		GameBoard.pieceList[PieceIndex(piece, GameBoard.pieceNumber[piece])] = square;
		GameBoard.pieceNumber[piece]++;

	}

	function MovePiece(from, to){

		var index = 0;
		var piece = GameBoard.pieces[from];

		HashPiece(piece, from);
		GameBoard.pieces[from] = Pieces.Empty;

		HashPiece(piece, to);
		GameBoard.pieces[to] = piece;

		for(index = 0; index < GameBoard.pieceNumber[piece]; ++index){

			if(GameBoard.pieceList[PieceIndex(piece, index)] == from){

				GameBoard.pieceList[PieceIndex(piece, index)] = to;
				break;

			}
		}
	}

	function MakeMove(move){

		var from = FromSquare(move);
		var to = ToSquare(move);
		var side = GameBoard.side;

		GameBoard.history[GameBoard.hisPly].positionKey = GameBoard.positionKey;

		if( (move & MoveFlagEnPassant) != 0) {
			if(side == Colours.white){

				ClearPiece(to - 10);

			} else {

				ClearPiece(to + 10);

			}
		} else if( (move & MoveFlagCastling) != 0) {

			switch(to){

				case Squares.C1: MovePiece(Squares.A1, Squares.D1);
				break;
				case Squares.C8: MovePiece(Squares.A8, Squares.D8);
				break;
				case Squares.G1: MovePiece(Squares.H1, Squares.F1);
				break;
				case Squares.G8: MovePiece(Squares.H8, Squares.F8);
				break;
				default: break;

			}
		}

		if(GameBoard.enPassant != Squares.noSquare) HashEnPassant();

		HashCastling();
		GameBoard.history[GameBoard.hisPly].move = move;
		GameBoard.history[GameBoard.hisPly].fiftyMove = GameBoard.fiftyMove;
		GameBoard.history[GameBoard.hisPly].enPassant = GameBoard.enPassant;
		GameBoard.history[GameBoard.hisPly].castlePermission = GameBoard.castlePermission;
		GameBoard.castlePermission &= CastlePermission[from];
		GameBoard.castlePermission &= CastlePermission[to];
		GameBoard.enPassant = Squares.noSquare;
		HashCastling();

		var captured = Captured(move);
		
		GameBoard.fiftyMove++;
		
		if(captured != Pieces.Empty){

			ClearPiece(to);
			GameBoard.fiftyMove = 0;

		}

		GameBoard.hisPly++;
		GameBoard.ply++;

		if(PiecePawn[GameBoard.pieces[from]] == Bool.true){

			GameBoard.fiftyMove = 0;

			if( (move & MoveFlagPawnStart) != 0){
				if(side==Colours.white){
	
					GameBoard.enPassant = from + 10;

				} else {

					GameBoard.enPassant = from - 10;

				}

				HashEnPassant();
			
			}
		}

		MovePiece(from, to);

		var promotedPiece = Promoted(move);

		if(promotedPiece != Pieces.Empty){

			ClearPiece(to);
			AddPiece(to, promotedPiece);

		}

		GameBoard.side ^= 1;
		HashSide();

		if(SquareAttacked(GameBoard.pieceList[PieceIndex(Kings[side], 0)], GameBoard.side)){

			TakeMove();
			return Bool.false;

		}

		return Bool.true;

	}

	function TakeMove(){

		GameBoard.hisPly--;
		GameBoard.ply--;

		var move = GameBoard.history[GameBoard.hisPly].move;
		var from = FromSquare(move);
		var to = ToSquare(move);

		if(GameBoard.enPassant != Squares.noSquare) HashEnPassant();
		
		HashCastling();
		GameBoard.castlePermission = GameBoard.history[GameBoard.hisPly].castlePermission;
		GameBoard.fiftyMove = GameBoard.history[GameBoard.hisPly].fiftyMove;
		GameBoard.enPassant = GameBoard.history[GameBoard.hisPly].enPassant;
		
		if(GameBoard.enPassant != Squares.noSquare) HashEnPassant();
		HashCastling();

		GameBoard.side ^= 1;
		HashSide();

		if( (MoveFlagEnPassant & move) != 0){
			if(GameBoard.side == Colours.white){

				AddPiece(to - 10, Pieces.blackPawn);

			} else {

				AddPiece(to + 10, Pieces.whitePawn);

			}
		} else if( (MoveFlagCastling & move) != 0) {

			switch(to){

				case Squares.C1: MovePiece(Squares.D1, Squares.A1);
				break;
				case Squares.C8: MovePiece(Squares.D8, Squares.A8);
				break;
				case Squares.G1: MovePiece(Squares.F1, Squares.H1);
				break;
				case Squares.G8: MovePiece(Squares.F8, Squares.H8);
				break;
				default: break;

			}
		}

		MovePiece(to, from);

		var captured = Captured(move);

		if(captured != Pieces.Empty){

			AddPiece(to, captured);

		}

		if(Promoted(move) != Pieces.Empty){

			ClearPiece(from);
			AddPiece(from, (PieceColour[Promoted(move)] == Colours.white ? Pieces.whitePawn : Pieces.blackPawn));

		}
	}

	var PawnTable = [
	0, 0, 0, 0, 0, 0, 0, 0,
	10, 10, 0, -10, -10, 0, 10, 10,
	5, 0, 0, 5, 5, 0, 0, 5,
	0, 0, 10, 20, 20, 10, 0, 0,
	5, 5, 5, 10, 10, 5, 5, 5,
	10, 10, 10, 20, 20, 10, 10, 10,
	20, 20, 20, 30, 30, 20, 20, 20,
	0, 0, 0, 0, 0, 0, 0, 0 ];

	var KnightTable = [
	0, -10, 0, 0, 0, 0, -10, 0,
	0, 0, 0, 5, 5, 0, 0, 0,
	0, 0, 10, 10, 10, 10, 0, 0,
	0, 0, 10, 20, 20, 10, 5, 0,
	5, 10, 15, 20, 20, 15, 10, 5,
	5, 10, 10, 20, 20, 10, 10, 5,
	0, 0, 5, 10, 10, 5, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0 ];

	var BishopTable = [
	0, 0, -10, 0, 0, -10, 0, 0,
	0, 0, 0, 10, 10, 0, 0, 0,
	0, 0, 10, 15, 15, 10, 0, 0,
	0, 10, 15, 20, 20, 15, 10, 0,
	0, 10, 15, 20, 20, 15, 10, 0,
	0, 0, 10, 15, 15, 10, 0, 0,
	0, 0, 0, 10, 10, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0 ];

	var RookTable = [
	0, 0, 5, 10, 10, 5, 0, 0,
	0, 0, 5, 10, 10, 5, 0, 0,
	0, 0, 5, 10, 10, 5, 0, 0,
	0, 0, 5, 10, 10, 5, 0, 0,
	0, 0, 5, 10, 10, 5, 0, 0,
	0, 0, 5, 10, 10, 5, 0, 0,
	25, 25, 25, 25, 25, 25, 25, 25,
	0, 0, 5, 10, 10, 5, 0, 0 ];

	var BishopPair = 40;

	function EvaluatePosition(){

		var score = GameBoard.material[Colours.white] - GameBoard.material[Colours.black];
		var piece;
		var square;
		var pieceNumber;

		piece = Pieces.whitePawn;

		for(pieceNumber = 0; pieceNumber < GameBoard.pieceNumber[piece]; ++pieceNumber){

			square = GameBoard.pieceList[PieceIndex(piece, pieceNumber)];
			score += PawnTable[Square64(square)];

		}

		piece = Pieces.blackPawn;

		for(pieceNumber = 0; pieceNumber < GameBoard.pieceNumber[piece]; ++pieceNumber){

			square = GameBoard.pieceList[PieceIndex(piece, pieceNumber)];
			score -= PawnTable[MIRROR64(Square64(square))];

		}

		piece = Pieces.whiteKnight;

		for(pieceNumber = 0; pieceNumber < GameBoard.pieceNumber[piece]; ++pieceNumber){

			square = GameBoard.pieceList[PieceIndex(piece, pieceNumber)];
			score += KnightTable[Square64(square)];

		}

		piece = Pieces.blackKnight;

		for(pieceNumber = 0; pieceNumber < GameBoard.pieceNumber[piece]; ++pieceNumber){

			square = GameBoard.pieceList[PieceIndex(piece, pieceNumber)];
			score -= KnightTable[MIRROR64(Square64(square))];

		}

		piece = Pieces.whiteBishop;

		for(pieceNumber = 0; pieceNumber < GameBoard.pieceNumber[piece]; ++pieceNumber){

			square = GameBoard.pieceList[PieceIndex(piece, pieceNumber)];
			score += BishopTable[Square64(square)];

		}

		piece = Pieces.blackBishop;

		for(pieceNumber = 0; pieceNumber < GameBoard.pieceNumber[piece]; ++pieceNumber){

			square = GameBoard.pieceList[PieceIndex(piece, pieceNumber)];
			score -= BishopTable[MIRROR64(Square64(square))];

		}

		piece = Pieces.whiteRook;

		for(pieceNumber = 0; pieceNumber < GameBoard.pieceNumber[piece]; ++pieceNumber){

			square = GameBoard.pieceList[PieceIndex(piece, pieceNumber)];
			score += RookTable[Square64(square)];

		}

		piece = Pieces.blackRook;

		for(pieceNumber = 0; pieceNumber < GameBoard.pieceNumber[piece]; ++pieceNumber){

			square = GameBoard.pieceList[PieceIndex(piece, pieceNumber)];
			score -= RookTable[MIRROR64(Square64(square))];

		}

		piece = Pieces.whiteQueen;

		for(pieceNumber = 0; pieceNumber < GameBoard.pieceNumber[piece]; ++pieceNumber){

			square = GameBoard.pieceList[PieceIndex(piece, pieceNumber)];
			score += RookTable[Square64(square)];

		}

		piece = Pieces.blackQueen;

		for(pieceNumber = 0; pieceNumber < GameBoard.pieceNumber[piece]; ++pieceNumber){

			square = GameBoard.pieceList[PieceIndex(piece, pieceNumber)];
			score -= RookTable[MIRROR64(Square64(square))];

		}

		if(GameBoard.pieceNumber[Pieces.whiteBishop] >= 2){

			score += BishopPair;

		}

		if(GameBoard.pieceNumber[Pieces.blackBishop] >= 2){

			score -= BishopPair;

		}

		if(GameBoard.side == Colours.white){

			return score;

		} else {

			return -score;

		}
	}

	function GetPvLine(depth){

		var move = ProbePvTable();
		var count = 0;

		while(move != NoMove && count < depth){

			if( MoveExists(move) == Bool.true) {

				MakeMove(move);
				GameBoard.PvArray[count++] = move;

			} else {

				break;

			}

			move = ProbePvTable();

		}

		while(GameBoard.ply > 0){

			TakeMove();

		}

		return count;

	}

	function ProbePvTable(){

		var index = GameBoard.positionKey % PvEntries;

		if(GameBoard.PvTable[index].positionKey == GameBoard.positionKey){

			return GameBoard.PvTable[index].move;

		}

		return NoMove;

	}

	function StorePvMove(move){

		var index = GameBoard.positionKey % PvEntries;
		
		GameBoard.PvTable[index].positionKey = GameBoard.positionKey;
		GameBoard.PvTable[index].move = move;

	}

	var SearchController = {};

	SearchController.nodes;
	SearchController.failHigh;
	SearchController.failHighFirst;
	SearchController.depth;
	SearchController.time;
	SearchController.start;
	SearchController.stop;
	SearchController.best;
	SearchController.thinking;

	function PickNextMove(MoveNumber){

		var index = 0; 
		var bestScore = -1;
		var bestNumber = MoveNumber;

		for (index = MoveNumber; index < GameBoard.moveListStart[GameBoard.ply + 1]; ++index){

			if (GameBoard.moveScores[index] > bestScore){

				bestScore = GameBoard.moveScores[index];
				bestNumber = index;

			}
		}

		if (bestNumber != MoveNumber){

			var temporary = 0;

			temporary = GameBoard.moveScores[MoveNumber];
			GameBoard.moveScores[MoveNumber] = GameBoard.moveScores[bestNumber];
			GameBoard.moveScores[bestNumber] = temporary;

			temporary = GameBoard.moveList[MoveNumber];
			GameBoard.moveList[MoveNumber] = GameBoard.moveList[bestNumber];
			GameBoard.moveList[bestNumber] = temporary;

		}
	}

	function ClearPvTable() {

		for(index = 0; index < PvEntries; ++index){

			GameBoard.PvTable[index].move = NoMove;
			GameBoard.PvTable[index].positionKey = 0;

		}
	}

	function CheckUp(){

		if (($.now() - SearchController.start ) > SearchController.time){

			SearchController.stop = Bool.true;

		}
	}

	function IsRepetition() { 

		var index = 0; 

		for(index = GameBoard.hisPly - GameBoard.fiftyMove; index < GameBoard.hisPly - 1; ++index){

			if(GameBoard.positionKey == GameBoard.history[index].positionKey){

				return Bool.true;

			}
		}

		return Bool.false;

	}

	function Quiescence(alpha, beta){

		if((SearchController.nodes & 2047) == 0){

			CheckUp();
	
		}

		SearchController.nodes++;

		if((IsRepetition() || GameBoard.fiftyMove >= 100) && GameBoard.ply != 0){

			return 0;

		}

		if(GameBoard.ply > maxDepth -1 ){

			return EvaluatePosition();

		}

		var Score = EvaluatePosition();

		if(Score >= beta){

			return beta;

		}

		if(Score > alpha){

			alpha = Score;

		}

		GenerateCaptures();

		var MoveNumber = 0;
		var Legal = 0;
		var OldAlpha = alpha;
		var BestMove = NoMove;
		var Move = NoMove;

		for(MoveNumber = GameBoard.moveListStart[GameBoard.ply]; MoveNumber < GameBoard.moveListStart[GameBoard.ply + 1]; ++MoveNumber){

			PickNextMove(MoveNumber);
			Move = GameBoard.moveList[MoveNumber];

			if(MakeMove(Move) == Bool.false){

				continue;

			}

			Legal++;
			Score = -Quiescence(-beta, -alpha);
			TakeMove();

			if(SearchController.stop == Bool.true){

				return 0;

			}

			if(Score > alpha){
				if(Score >= beta){
					if(Legal == 1){
		
						SearchController.failHighFirst++;

					}

					SearchController.failHigh++;
					return beta;

				}

				alpha = Score;
				BestMove = Move;

			}
		}

		if(alpha != OldAlpha){

			StorePvMove(BestMove);

		}

		return alpha;

	}

	function AlphaBeta(alpha, beta, depth){

		if(depth <= 0){

			return Quiescence(alpha, beta);

		}

		if((SearchController.nodes & 2047) == 0){

			CheckUp();
	
		}

		SearchController.nodes++;

		if((IsRepetition() || GameBoard.fiftyMove >= 100) && GameBoard.ply != 0){

			return 0;

		}

		if(GameBoard.ply > maxDepth -1 ){

			return EvaluatePosition();

		}

		var InCheck = SquareAttacked(GameBoard.pieceList[PieceIndex(Kings[GameBoard.side], 0)], GameBoard.side^1);

			if(InCheck == Bool.true) {

				depth++;

			}

		var Score = -infinite;

		GenerateMoves();

		var MoveNumber = 0;
		var Legal = 0;
		var OldAlpha = alpha;
		var BestMove = NoMove;
		var Move = NoMove;
		var PvMove = ProbePvTable();

		if(PvMove != NoMove){

			for(MoveNumber = GameBoard.moveListStart[GameBoard.ply]; MoveNumber < GameBoard.moveListStart[GameBoard.ply + 1]; ++MoveNumber){

				if(GameBoard.moveList[MoveNumber] == PvMove){

					GameBoard.moveScores[MoveNumber] = 2000000;
					break;

				}
			}
		}

		for(MoveNumber = GameBoard.moveListStart[GameBoard.ply]; MoveNumber < GameBoard.moveListStart[GameBoard.ply + 1]; ++MoveNumber){

			PickNextMove(MoveNumber);
			Move = GameBoard.moveList[MoveNumber];

			if(MakeMove(Move) == Bool.false){

				continue;

			}

			Legal++;
			Score = -AlphaBeta(-beta, -alpha, depth-1);
			TakeMove();

			if(SearchController.stop == Bool.true){

				return 0;

			}

			if(Score > alpha){
				if(Score >= beta){
					if(Legal == 1){
		
						SearchController.failHighFirst++;

					}

					SearchController.failHigh++;

					if((Move & MoveFlagCapture) == 0){

						GameBoard.searchKillers[maxDepth + GameBoard.ply] = GameBoard.searchKillers[GameBoard.ply];
						GameBoard.searchKillers[GameBoard.ply] = Move;

					}

					return beta;

				}

				if((Move & MoveFlagCapture) == 0){

					GameBoard.searchHistory[GameBoard.pieces[FromSquare(Move)] * Board + ToSquare(Move)] += depth * depth;

				}

				alpha = Score;
				BestMove = Move;

			}
		}

		if(Legal == 0){
			if(InCheck == Bool.true){

				return -mate + GameBoard.ply;

			} else {

				return 0;

			}
		}

		if(alpha != OldAlpha){

			StorePvMove(BestMove);

		}

		return alpha;

	}

	function ClearForSearch() {

		var index = 0;
		var index2 = 0;

		for(index = 0; index < 14 * Board; ++index){

			GameBoard.searchHistory[index] = 0;

		}

		for(index = 0; index < 3 * maxDepth; ++index){

			GameBoard.searchKillers[index] = 0;

		}

		ClearPvTable();
		GameBoard.ply = 0;
		SearchController.nodes = 0;
		SearchController.failHigh = 0;
		SearchController.failHighFirst = 0;
		SearchController.start = $.now();
		SearchController.stop = Bool.false;

	}

	function SearchPosition() {

		var bestMove = NoMove;
		var bestScore = -infinite;
		var Score = -infinite;
		var currentDepth = 0;
		var line;
		var PvNumber;
		var count;

		ClearForSearch();

		for(currentDepth = 1; currentDepth <= SearchController.depth; ++currentDepth){

			Score = AlphaBeta(-infinite, infinite, currentDepth);

			if(SearchController.stop == Bool.true){

				break;

			}

			bestScore = Score;
			bestMove = ProbePvTable();
			line = 'Depth: ' + currentDepth + ' Best: ' + PrintMove(bestMove) + ' Score: ' + bestScore + ' Nodes: ' + SearchController.nodes;
			PvNumber = GetPvLine(currentDepth);
			line += ' Pv:';

			for(count = 0; count < PvNumber; ++count){

				line += ' ' + PrintMove(GameBoard.PvArray[count]);

			}

			if(currentDepth != 1){

				line += (" Ordering: " + ((SearchController.failHighFirst/SearchController.failHigh)*100).toFixed(2) + "%");

			}

			console.log(line);

		}

		SearchController.best = bestMove;
		SearchController.thinking = Bool.false;
		UpdateDOMStats(bestScore, currentDepth);

	}

	function UpdateDOMStats(domScore, domDepth){

		var scoreText = "Score: " + (domScore / 100).toFixed(2);

		if(Math.abs(domScore) > mate - maxDepth) {

			scoreText = "Score: Mate In " + (mate - (Math.abs(domScore)) - 1) + " moves";

		}

		$("#Ordering").text("Ordering: " + ((SearchController.failHighFirst / SearchController.failHigh) * 100).toFixed(2) + "%");
		$("#Depth").text("Depth: " + domDepth);
		$("#Score").text(scoreText);
		$("#Nodes").text("Nodes: " + SearchController.nodes);
		$("#Time").text("Time: " + (($.now() - SearchController.start) / 1000).toFixed(1) + "s");
		$("#BestMove").text("Best Move: " + PrintMove(SearchController.best));

	}

	function Perft(depth){

		if(depth == 0){

			perftLeafNodes++;
			return;

		}

		GenerateMoves();

		var index;
		var move;

		for(index = GameBoard.moveListStart[GameBoard.ply]; index < GameBoard.moveListStart[GameBoard.ply + 1]; ++index){

			move = GameBoard.moveList[index];
			if(MakeMove(move) == Bool.false){

				continue;

			}

			Perft(depth-1);
			TakeMove();

		}

		return;

	}

	function PerftTest(depth){

		PrintBoard();
		console.log("Test To Depth:" + depth);
		perftLeafNodes = 0;
		GenerateMoves();

		var index;
		var move;
		var moveNumber = 0;

		for(index = GameBoard.moveListStart[GameBoard.ply]; index < GameBoard.moveListStart[GameBoard.ply + 1]; ++index){

			move = GameBoard.moveList[index];

			if(MakeMove(move) == Bool.false){

				continue;

			}

			moveNumber++;

			var cumulativeNodes = perftLeafNodes;

			Perft(depth-1);
			TakeMove();

			var oldNodes = perftLeafNodes - cumulativeNodes;

			console.log("move:" + moveNumber + " " + PrintMove(move) + " " + oldNodes);

		}

		console.log("Test Complete: " + perftLeafNodes + " leaf nodes visited");

		return;

	}

	function Mirror120(square) {

		var file = MirrorFiles[filesBoard[square]];
		var rank = MirrorRanks[ranksBoard[square]];

		return FilePlusRankOnSquare(file, rank);

	}

	$("#setFEN").click(function () {

		var fenString = $("#fenIn").val();
		NewGame(fenString);

	});

	$('#TakeBack').click( function() { 

		if(GameBoard.hisPly > 0) {

			TakeMove();
			GameBoard.ply = 0;
			SetInitialBoardPieces();

		}
	});

	$('#NewGame').click( function() {

		NewGame(startFEN);

	});

	$('#FlipBoard').click( function() {

		GameController.BoardFlipped ^= 1;
		SetInitialBoardPieces();

	});

	function NewGame(fenString) {

		ParseFEN(fenString);
		PrintBoard();
		SetInitialBoardPieces();
		CheckAndSet();

	}

	function ClearAllPieces() {

		$(".Piece").remove();

	}

	function SetInitialBoardPieces() {

		var square;
		var square120;
		var file;
		var rank;
		var rankName;
		var fileName;
		var imageString;
		var pieceFileName;
		var piece;

		ClearAllPieces();

		for(square = 0; square < 64; ++square){

			square120 = Square120(square);
			piece = GameBoard.pieces[square120];

			if(GameController.BoardFlipped == Bool.true) {

				square120 = Mirror120(square120);

			}

			file = filesBoard[square120];
			rank = ranksBoard[square120];
			
			if(piece >= Pieces.whitePawn && piece <= Pieces.blackKing){

				rankName = "Rank" + (rank + 1);
				fileName = "File" + (file + 1);
				pieceFileName = "Images/" + SideChar[PieceColour[piece]] + PieceChar[piece].toUpperCase() + ".png";
				imageString = "<image src=\"" + pieceFileName + "\" class=\"Piece " + rankName + " " + fileName + "\"/>";
				$("#Board").append(imageString);

			}
		}
	}
	
	function DeSelectSquare(square){

		if(GameController.BoardFlipped == Bool.true){

			square = Mirror120(square);

		}

		$('.Square').each(function(index) {

			if ((ranksBoard[square] == 7 - Math.round($(this).position().top / 60)) && (filesBoard[square] == Math.round($(this).position().left / 60))) {

				$(this).removeClass('SquareSelected');

			}
		});
	}

	function SetSquareSelected(square) {

		if (GameController.BoardFlipped == Bool.true) {

			square = Mirror120(square);

		}

		$('.Square').each(function(index) {

			if ((ranksBoard[square] == 7 - Math.round($(this).position().top / 60)) && (filesBoard[square] == Math.round($(this).position().left / 60))) {

				$(this).addClass('SquareSelected');

			}
		});
	}

	function ClickedSquare(pageX, pageY) {

		console.log('ClickedSquare() at ' + pageX + ',' + pageY);

		var position = $('#Board').position();
		var workedX = Math.floor(position.left);
		var workedY = Math.floor(position.top);
	
		pageX = Math.floor(pageX);
		pageY = Math.floor(pageY);

		var file = Math.floor((pageX - workedX) / 60);
		var rank = 7 - Math.floor((pageY - workedY) / 60);
		var square = FilePlusRankOnSquare(file, rank);

		if(GameController.BoardFlipped == Bool.true){

			square = Mirror120(square);

		}

		console.log('Clicked square:' + PrintSquare(square));
		
		SetSquareSelected(square);

		return square;

	}

	$(document).on('click', '.Piece', function (e) {

		console.log('Piece Click');

		if(UserMove.from == Squares.noSquare){

			UserMove.from = ClickedSquare(e.pageX, e.pageY);

		} else {

			UserMove.to = ClickedSquare(e.pageX, e.pageY);

		}

		MakeUserMove();

	});

	$(document).on('click', '.Square', function (e) {

		console.log('Square Click');

		if(UserMove.from != Squares.noSquare){

			UserMove.to = ClickedSquare(e.pageX, e.pageY);
			MakeUserMove();

		}
	});

	function MakeUserMove() {

		if(UserMove.from != Squares.noSquare && UserMove.to != Squares.noSquare){

			console.log("User Move:" + PrintSquare(UserMove.from) + PrintSquare(UserMove.to));

			var parsed = ParseMove(UserMove.from, UserMove.to);

			if(parsed != NoMove){

				MakeMove(parsed);
				PrintBoard();
				MoveGUIPiece(parsed);
				CheckAndSet();
				PreSearch();

			}

			DeSelectSquare(UserMove.from);
			DeSelectSquare(UserMove.to);

			UserMove.from = Squares.noSquare;
			UserMove.to = Squares.noSquare;

		}
	}

	function PieceIsOnSquare(square, top, left){

		if((ranksBoard[square] == 7 - Math.round(top / 60)) && filesBoard[square] == Math.round(left / 60)){

			return Bool.true;

		}

		return Bool.false;

	}

	function RemoveGUIPiece(square){

		$('.Piece').each(function(index) {

			if (PieceIsOnSquare(square, $(this).position().top, $(this).position().left) == Bool.true){

				$(this).remove();

			}
		});
	}

	function AddGUIPiece(square, piece){

		var file = filesBoard[square];
		var rank = ranksBoard[square];
		var rankName = "Rank" + (rank + 1);
		var fileName = "File" + (file + 1);
		var pieceFileName = "Images/" + SideChar[PieceColour[piece]] + PieceChar[piece].toUpperCase() + ".png";
		var imageString = "<image src=\"" + pieceFileName + "\" class=\"Piece clickElement " + rankName + " " + fileName + "\"/>";
		$("#Board").append(imageString);

	}

	function MoveGUIPiece(move) {

		var from = FromSquare(move);
		var to = ToSquare(move);
		var flippedFrom = from;
		var flippedTo = to;
		var enPassantWhite = -10;
		var enPassantBlack = 10;

		if(GameController.BoardFlipped == Bool.true){

			flippedFrom = Mirror120(from);
			flippedTo = Mirror120(to);
			enPassantWhite = 10;
			enPassantBlack = -10;

		}

		if(move & MoveFlagEnPassant) {

			var enPassantRemove;

			if(GameBoard.side == Colours.black) {

				enPassantRemove = flippedTo + enPassantWhite;

			} else {

				enPassantRemove = flippedTo + enPassantBlack;

			}

			RemoveGUIPiece(enPassantRemove);

		} else if(Captured(move)) {

			RemoveGUIPiece(flippedTo);

		}

		var file = filesBoard[flippedTo];
		var rank = ranksBoard[flippedTo];
		var rankName = "Rank" + (rank + 1);
		var fileName = "File" + (file + 1);

		$('.Piece').each(function(index) {

			if((ranksBoard[flippedFrom] == 7 - Math.round($(this).position().top / 60)) && (filesBoard[flippedFrom] == Math.round($(this).position().left / 60))){

				$(this).removeClass();
				$(this).addClass("Piece clickElement " + rankName + " " + fileName);

			}
		});

		if(move & MoveFlagCastling) {
			if(GameController.BoardFlipped == Bool.true) {

				switch(to) {

					case Squares.G1: RemoveGUIPiece(Mirror120(Squares.H1)); AddGUIPiece(Mirror120(Squares.F1), Pieces.whiteRook); break;
					case Squares.C1: RemoveGUIPiece(Mirror120(Squares.A1)); AddGUIPiece(Mirror120(Squares.D1), Pieces.whiteRook); break;
					case Squares.G8: RemoveGUIPiece(Mirror120(Squares.H8)); AddGUIPiece(Mirror120(Squares.F8), Pieces.blackRook); break;
					case Squares.C8: RemoveGUIPiece(Mirror120(Squares.A8)); AddGUIPiece(Mirror120(Squares.D8), Pieces.blackRook); break;

				}
			} else {

				switch(to) {

					case Squares.G1: RemoveGUIPiece(Squares.H1); AddGUIPiece(Squares.F1, Pieces.whiteRook); break;
					case Squares.C1: RemoveGUIPiece(Squares.A1); AddGUIPiece(Squares.D1, Pieces.whiteRook); break;
					case Squares.G8: RemoveGUIPiece(Squares.H8); AddGUIPiece(Squares.F8, Pieces.blackRook); break;
					case Squares.C8: RemoveGUIPiece(Squares.A8); AddGUIPiece(Squares.D8, Pieces.blackRook); break;

				}
			}
		}

		var promotion = Promoted(move);

		if(promotion != Pieces.Empty) {

			RemoveGUIPiece(flippedTo);
			AddGUIPiece(flippedTo, promotion);

		}
	}

	function DrawMaterial(){

		if (GameBoard.pieceNumber[Pieces.whitePawn] != 0 || GameBoard.pieceNumber[Pieces.blackPawn] != 0) return Bool.false;
		if (GameBoard.pieceNumber[Pieces.whiteQueen] != 0 || GameBoard.pieceNumber[Pieces.blackQueen] != 0 || GameBoard.pieceNumber[Pieces.whiteRook] != 0 || GameBoard.pieceNumber[Pieces.blackRook] != 0) return Bool.false;
		if (GameBoard.pieceNumber[Pieces.whiteBishop] > 1 || GameBoard.pieceNumber[Pieces.blackBishop] > 1) { return Bool.false; }
		if (GameBoard.pieceNumber[Pieces.whiteKnight] > 1 || GameBoard.pieceNumber[Pieces.blackKnight] > 1) { return Bool.false; }
		if (GameBoard.pieceNumber[Pieces.whiteKnight] != 0 || GameBoard.pieceNumber[Pieces.whiteBishop] != 0) { return Bool.false; }
		if (GameBoard.pieceNumber[Pieces.blackKnight] != 0 || GameBoard.pieceNumber[Pieces.blackBishop] != 0) { return Bool.false; }

		return Bool.true;

	}

	function ThreeFoldRepetition(){

		var i = 0, r = 0;

		for (i = 0; i < GameBoard.hisPly; ++i) {

			if (GameBoard.history[i].positionKey == GameBoard.positionKey) {

				r++;
	
			}	
		}

		return r;

	}

	function CheckResult() {

		if(GameBoard.fiftyMove >= 100) {

			$("#GameStatus").text("GAME DRAWN {Fifty Move Rule}");
			return Bool.true;

		}

		if(ThreeFoldRepetition() >= 2) {

			$("#GameStatus").text("GAME DRAWN {3-Fold Repetition}");
			return Bool.true;

		}

		if(DrawMaterial() == Bool.true) {

			$("#GameStatus").text("GAME DRAWN {Insufficient Material to Mate}");
			return Bool.true;

		}

		GenerateMoves();

		var MoveNumber = 0;
		var found = 0;

		for(MoveNumber = GameBoard.moveListStart[GameBoard.ply]; MoveNumber < GameBoard.moveListStart[GameBoard.ply + 1]; ++MoveNumber) {

			if (MakeMove(GameBoard.moveList[MoveNumber]) == Bool.false) {

				continue;

			}

			found++;
			TakeMove();
			break;

		}

		if(found != 0) return Bool.false;

		var InCheck = SquareAttacked(GameBoard.pieceList[PieceIndex(Kings[GameBoard.side], 0)], GameBoard.side^1);

		if(InCheck == Bool.true){
			if(GameBoard.side == Colours.white) {

				$("#GameStatus").text("GAME OVER {Black Mates}");
				return Bool.true;

			} else {

				$("#GameStatus").text("GAME OVER {White Mates}");
				return Bool.true;

			}
		} else {

			$("#GameStatus").text("GAME DRAWN {Stalemate}"); return Bool.true;

		}

		return Bool.false;

	}

	function CheckAndSet(){

		if(CheckResult() == Bool.true) {

			GameController.GameOver = Bool.true;

		} else {

			GameController.GameOver = Bool.false;
			$("#GameStatus").text('');

		}
	}

	function PreSearch() {

		if(GameController.GameOver == Bool.false) {

			SearchController.thinking = Bool.true;
			setTimeout( function() { StartSearch(); }, 200);

		}
	}

	$('#Search').click( function() {

		GameController.PlayerSide = GameController.side ^ 1;
		PreSearch();

	});

	function StartSearch() {

		SearchController.depth = maxDepth;

		var time = $.now();
		var thinkingTime = $('#ThinkTimeChoice').val();

		SearchController.time = parseInt(thinkingTime) * 1000;
		SearchPosition();

		MakeMove(SearchController.best);
		MoveGUIPiece(SearchController.best);
		CheckAndSet();

	}

	$(function(){

		init();
		NewGame(startFEN);

	});

	function InitFilesRanksBrd() {

		var index = 0;
		var file = Files.fileA;
		var rank = Ranks.rank1;
		var sq = Squares.A1;

		for(index = 0; index < Board; ++index) {

			filesBoard[index] = Squares.offBoard;
			ranksBoard[index] = Squares.offBoard;

		}

		for(rank = Ranks.rank1; rank <= Ranks.rank8; ++rank){
			
			for(file = Files.fileA; file <= Files.fileH; ++file){

				sq = FilePlusRankOnSquare (file, rank);
				filesBoard[sq] = file;
				ranksBoard[sq] = rank;
			}
		}
	}

	function InitHashKeys(){

		var index = 0;

		for(index = 0; index < 14 * 120; ++index){

			PieceKeys[index] = Random31();

		}

		SideKey = Random31();

		for(index = 0; index < 16; ++index){

			CastleKeys[index] = Random31(); 

		}
	}

	function InitSquare120ToSquare64(){
		
		var index = 0;
		var file = Files.fileA;
		var rank = Ranks.rank1;
		var square = Squares.A1;
		var square64 = 0;
		
		for(index = 0; index < Board; ++index){
			
			Square120ToSquare64[index] = 65;
			
		}
		
		for(index = 0; index < 64; ++index){
			
			Square64ToSquare120[index] = 120;
			
		}
		
		for(rank = Ranks.rank1; rank <= Ranks.rank8; ++rank){
			for(file = Files.fileA; file <= Files.fileH; ++file){
				
				square = FilePlusRankOnSquare(file, rank);
				Square64ToSquare120[square64] = square;
				Square120ToSquare64[square] = square64;
				square64++;
				
			}
		}
	}

	function InitBoardVariables(){

		var index = 0;

		for(index = 0; index < maxGameMoves; ++index){

			GameBoard.history.push( {

				move : NoMove,
				castlePermission : 0,
				enPassant : 0,
				fiftyMove : 0,
				positionKey : 0

			});
		}

		for(index = 0; index < PvEntries; ++index){

			GameBoard.PvTable.push({

				move : NoMove,
				positionKey : 0

			});
		}
	}

	function InitBoardSquares(){

		var light = 1;
		var rankName;
		var fileName;
		var divString;
		var rankIterator;
		var fileIterator;
		var lightString;

		for (rankIterator = Ranks.rank8; rankIterator >= Ranks.rank1; rankIterator--){

			light ^= 1;
			rankName = "Rank" + (rankIterator + 1);

			for(fileIterator = Files.fileA; fileIterator <= Files.fileH; fileIterator++){
			
				fileName = "File" + (fileIterator + 1);
				if(light == 0) lightString = "Light";
				else lightString = "Dark";
				light ^= 1;
				divString = "<div class=\"Square clickElement " + rankName + " " + fileName + " " + lightString + "\"/>";
				$("#Board").append(divString);
	
			}
		}
	}

	function init(){

		InitFilesRanksBrd();
		InitHashKeys();
		InitSquare120ToSquare64();
		InitBoardVariables();
		InitMvvLva();
		InitBoardSquares();

	}

</script>

</body>

</html>